class QuickRequestException{constructor(custom){const error=new Error(custom);throw console.error("⚠ QuickRequestException ⚠ | "+error.toString(),{name:error.name,message:error.message,trace:error.stack.split("\n").map(function(element){return element.trim().replaceAll("at ","🔍 At: ")})})}}const QuickRequestHelpers={extractLastSegment:(value,separator="/")=>{if(!QuickRequestHelpers.isValueEmpty(value)){const segments=value.split(separator);const lastSegment=segments[segments.length-1];return lastSegment}return""},isValueEmpty:value=>{if(value==null){return true}if(typeof value==="string"&&value.trim()===""){return true}if(Array.isArray(value)&&value.length===0){return true}if(typeof value==="object"&&Object.keys(value).length===0){return true}return false},getTokenCSRF:()=>{const csrfTokenMeta=document.querySelector('meta[name="csrf-token"]');if(csrfTokenMeta){return csrfTokenMeta.getAttribute("content")}else{throw new QuickRequestException(`The meta tag "csrf-token" was not found. Please remember to add it in the head section: <meta name="csrf-token" content="{{ csrf_token() }}">`)}}};class QuickRequestValidate{constructor(options){const required=["url"];required.forEach(element=>{let exist=options.hasOwnProperty(element);if(!exist){throw new QuickRequestException("The property '"+element+"' is mandatory in the request options.")}})}}class QuickRequestElements{tagCheck(element){const validTags=["INPUT","TEXTAREA","SELECT"];return validTags.includes(element.tagName)}typeCheck(element){const disabledTypes=["submit","button"];return!disabledTypes.includes(element.type)}typeFile(element){return element.type==="file"}typeCheckboxOrRadio(element){const validTypes=["radio","checkbox"];return validTypes.includes(element.type)}}class QuickRequestMain{constructor(){this.config={expect:"JSON",confirm:false,activateEvent:false,eventListener:{},preventDefault:true,method:"GET",headers:{"X-CSRF-TOKEN":QuickRequestHelpers.getTokenCSRF(),Accept:"application/json"}}}eventListener(event,selectors){if(QuickRequestHelpers.isValueEmpty(event)){throw new QuickRequestException("You must define a valid event within the eventListener method(<<Method>>,<<Selectors>>)")}if(QuickRequestHelpers.isValueEmpty(selectors)){throw new QuickRequestException("You must define a valid selector within the eventListener method(<<Method>>,<<Selectors>>)")}this.config.activateEvent=true;this.config.eventListener.event=event;this.config.eventListener.selectors=document.querySelectorAll(selectors);return this}preventDefault(state=true){if(state!==true&&state!==false){throw new QuickRequestException("The argument can only be <<true>> or <<false>>, or omit it to default to <<true>>")}this.config.preventDefault=state;return this}headers(headersCustom={}){this.config.headers={...this.config.headers,...headersCustom};return this}confirm(callback){this.config.confirm=callback;return this}post(options={}){this.config.method="POST";if(options.hasOwnProperty("headers")){this.headers(options.headers);delete options["headers"]}this.config.options=options;this.config.expect=options.expect||"JSON";const manager=new QuickRequestEvents(this.config);return manager.handler}get(options={}){this.config.method="GET";if(options.hasOwnProperty("headers")){this.headers(options.headers);delete options["headers"]}this.config.options=options;this.config.expect=options.expect||"JSON";const manager=new QuickRequestEvents(this.config);return manager.handler}put(options={}){this.config.method="PUT";if(options.hasOwnProperty("headers")){this.headers(options.headers);delete options["headers"]}this.config.options=options;this.config.expect=options.expect||"JSON";const manager=new QuickRequestEvents(this.config);return manager.handler}patch(options={}){this.config.method="PATCH";if(options.hasOwnProperty("headers")){this.headers(options.headers);delete options["headers"]}this.config.options=options;this.config.expect=options.expect||"JSON";const manager=new QuickRequestEvents(this.config);return manager.handler}"delete"(options={}){this.config.method="DELETE";if(options.hasOwnProperty("headers")){this.headers(options.headers);delete options["headers"]}this.config.options=options;this.config.expect=options.expect||"JSON";const manager=new QuickRequestEvents(this.config);return manager.handler}}class QuickRequestEvents{constructor(config){this.config=config;this.config.callbacksEvents=[];new QuickRequestValidate(this.config.options);this.checkEvent()}checkEvent(){if(this.config.activateEvent){const self=this;this.config.eventListener.selectors.forEach(function(element){const funcEvent=function(e){if(self.config.preventDefault){e.preventDefault()}new QuickRequestFetch(self.config)};element.addEventListener(self.config.eventListener.event,funcEvent);self.config.callbacksEvents.push({element:element,event:self.config.eventListener.event,func:funcEvent})});self.handler=new QuickRequesHandler(self.config)}else{new QuickRequestFetch(this.config);this.handler=new QuickRequesHandler(this.config)}}}class QuickRequestFetch{constructor(config){this.config=config;this.config.baseUrl=`${window.location.protocol}//${window.location.host}/`;this.config.formData=new FormData;this.config.hasFile=false;this.custom={};this.dispatch()}data(){const originForm=this.config.options.form||null;if(originForm!==null){const inputsCheck=new QuickRequestElements;let controls=[];const realElementForm=document.getElementById(originForm);if(realElementForm){controls=Array.from(realElementForm.elements)}else{throw new QuickRequestException("Could not find any form with the id "+originForm)}controls.forEach(element=>{if(inputsCheck.tagCheck(element)&&inputsCheck.typeCheck(element)){if(inputsCheck.typeFile(element)){if(element.files.length>0){this.config.formData.append(element.name,element.files[0]);this.config.hasFile=true}}else if(inputsCheck.typeCheckboxOrRadio(element)){if(element.checked){this.config.formData.append(element.name,element.value)}}else{if(!QuickRequestHelpers.isValueEmpty(element.value)){this.config.formData.append(element.name,element.value)}}}});const originData=this.config.options.data||null;if(!QuickRequestHelpers.isValueEmpty(originData)){for(const[key,value]of Object.entries(originData)){this.config.formData.append(key,value)}}}else{let originData;if(typeof this.config.options.data==="function"){originData=this.config.options.data(this.custom)}else{originData=this.config.options.data||null}if(!QuickRequestHelpers.isValueEmpty(originData)){for(const[key,value]of Object.entries(originData)){this.config.formData.append(key,value)}}}}method(){let url=(this.config.baseUrl+this.config.options.url).replaceAll("//","/").replaceAll(":/","://");let params={};if(["GET","HEAD"].includes(this.config.method)){if(this.config.hasFile){throw new QuickRequestException("File uploads are not allowed with "+this.config.method+" due to URL length limitations; use POST instead.")}if(url.includes("?")){throw new QuickRequestException("The URL appears to already have a query, as it contains the '?' character in its structure. In case you need to send additional data, use the 'data' property.")}let query=new URLSearchParams(this.config.formData).toString();url=`${url}?${query}`;params={method:this.config.method,headers:this.config.headers}}else if(["PATCH","PUT","DELETE"].includes(this.config.method)){if(this.config.hasFile){throw new QuickRequestException("File uploads are not allowed with "+this.config.method+" as it uses JSON headers; use POST instead.")}let jsonObject={};for(let[clave,valor]of this.config.formData.entries()){let isArray=clave.includes("[]");let index=clave.replace("[]","");if(jsonObject[index]===undefined){if(isArray){jsonObject[index]=[valor]}else{jsonObject[index]=valor}}else{try{jsonObject[index].push(valor)}catch(error){throw new QuickRequestException("Two distinct inputs, excluding Checkboxes and Radios, have the same name '"+index+"' without the square brackets '[]', which prevents them from being treated as the same data when sent to the backend as an array.")}}}this.config.headers["Content-Type"]="application/json";params={method:this.config.method,headers:this.config.headers,body:JSON.stringify(jsonObject)}}else{params={method:this.config.method,headers:this.config.headers,body:this.config.formData}}const propertiesToValidate=["mode","cache","credentials","redirect","referrerPolicy"];for(const property of propertiesToValidate){if(this.config.hasOwnProperty(property)){params[property]=this.config[property]}}return{realUrl:url,realParams:params}}dispatch(){if(typeof this.config.confirm==="function"){if(this.config.confirm(this.custom)===true){this.send()}}else{this.send()}}async send(){this.data();if(this.config.options.before&&typeof this.config.options.before==="function"){this.config.options.before(this.custom)}let custom_response;let custom_data;let custom_status;let errors;let responseJSON;const params=this.method();const response=await fetch(params.realUrl,params.realParams);if(!response.ok){try{responseJSON=await response.json()}catch(error){responseJSON=response.statusText}if(typeof responseJSON=="string"){errors={message:responseJSON,errors:[]}}else{if(responseJSON.hasOwnProperty("exception")&&responseJSON.hasOwnProperty("file")&&responseJSON.hasOwnProperty("message")){errors={message:responseJSON.message,errors:[]};responseJSON.trace.forEach(element=>{if(element["class"]){errors.errors[`${element["class"]}:${element.line}`]=[`${element.file}${element.type}${element["function"]}`]}})}else if(typeof responseJSON==="object"&&Object.keys(responseJSON).length>0){errors={message:responseJSON.message||response.statusText,errors:responseJSON.errors||[]}}else{errors={message:response.statusText,errors:[]}}custom_response={data:errors,success:response.ok,status:response.status,statusText:response.statusText,headers:response.headers,url:response.url};custom_data=errors;custom_status=response.status}if(this.config.options.error&&typeof this.config.options.error==="function"){this.config.options.error(custom_response,custom_data,custom_status)}}else{try{if(this.config.expect.toLowerCase().trim()=="json"){try{responseJSON=await response.json()}catch(error){responseJSON=null}}else if(this.config.expect.toLowerCase().trim()=="text"){try{responseJSON=await response.text()}catch(error){responseJSON=null}}else if(this.config.expect.toLowerCase().trim()=="blob"){try{responseJSON=await response.blob()}catch(error){responseJSON=null}}else{throw new Error("Only the values 'json', 'blob' or 'text' are allowed for the 'expect' property.")}}catch(error){throw new QuickRequestException(error.message)}custom_response={data:responseJSON,success:response.ok,status:response.status,statusText:response.statusText,headers:response.headers,url:response.url};custom_data=responseJSON;custom_status=response.status;this.config.options.success(custom_response,custom_data,custom_status)}if(this.config.options.after&&typeof this.config.options.after==="function"){this.config.options.after(custom_response,custom_data,custom_status)}}}class QuickRequesHandler{constructor({callbacksEvents,headers,method,options,preventDefault}){this.getMethod=function(){return method};this.getEndPoint=function(){return options.url};this.getIdForm=function(){return options.form||null};this.getData=function(){return options.data||null};this.getCustomHeaders=function(){return headers};this.getEvents=function(){return{preventDefault:!QuickRequestHelpers.isValueEmpty(callbacksEvents)?preventDefault:null,events:callbacksEvents}};this.call=function(){return{before:options.before,success:options.success,error:options.error,after:options.after}};this.getParams=function(){return options};this.removeEventListener=function(){if(!QuickRequestHelpers.isValueEmpty(callbacksEvents)){callbacksEvents.forEach(data=>{data.element.removeEventListener(data.event,data.func)});this.getEvents=function(){return[]};return true}return false}}}export const QuickRequestBlobs={config:{blob:null,name:null,extension:null},setBlob:function(blob){this.config.blob=blob;return this},setName:function(name){this.config.name=name;return this},setExtension:function(extension){this.config.extension=extension;return this},download:function(){let{blob,name,extension}=this.config;if(!blob){throw new QuickRequestException("Blob is not set in QuickRequestBlobs.setBlob().")}if(!name){throw new QuickRequestException("Name is not set in QuickRequestBlobs.setName().")}if(extension===null&&blob.type){const mimeTypeParts=blob.type.split("/");if(mimeTypeParts.length>=1){extension=mimeTypeParts[1]}}if(extension===null){throw new QuickRequestException("Extension is not set in QuickRequestBlobs.setExtension().")}const blobUrl=URL.createObjectURL(blob);const nameWithExtension=(name+"."+extension).replaceAll("..",".");const downloadLink=document.createElement("a");downloadLink.href=blobUrl;downloadLink.download=nameWithExtension;downloadLink.textContent=name;const event=new MouseEvent("click",{view:window,bubbles:true,cancelable:false});downloadLink.dispatchEvent(event)}};export const QuickRequest=()=>new QuickRequestMain;